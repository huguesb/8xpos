.nolist
; Copyright (c) 2009, Luc BRUANT aka fullmetalcoder.
;Redistribution and use in source and binary forms, with or without modification, are
;permitted provided that the following conditions are met:
;Redistributions of source code must retain the above copyright notice, this list of
;conditions and the following disclaimer.
;
;Redistributions in binary form must reproduce the above copyright notice, this list of
;conditions and the following disclaimer in the documentation and/or other materials
;provided with the distribution.
;
;THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
;"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
;TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
;PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
;CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
;EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
;PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
;PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
;OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
;NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
;SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
.list

.nolist
; OS config file
#include "xos.inc"
; syscalls addresses
#include "xos.exp"
; library header file
#include "apps/gui.inc"
.list

#define t_dump call dump.pool

#define t_malloc(n,sz) ld bc, sz \ call zp.malloc \ ld (n*2 + slots), hl \ t_dump
#define t_free(n) ld hl, (n*2 + slots) \ call zp.free \ t_dump
#define t_realloc(n,sz) ld hl, (n*2 + slots) \ ld bc, sz \ call zp.realloc \ ld (n*2 + slots), hl \ t_dump

.org	prgm.start - 2
	.db magic.executable, 0
	
	jp	vat.test
	
	; first test malloc/free/realloc
malloc.test:
	
	t_malloc(0, $0100)
	t_malloc(1, $0100)
	t_malloc(2, $0100)
	t_malloc(3, $0100)
	t_free(1)
	t_free(2)
	t_malloc(1, $0200)
	t_realloc(0, $0200)
	t_free(3)
	t_realloc(1, $0300)
	
	t_free(1)
	t_free(0)
	
	ret

slots:
	.dw 0, 0, 0, 0

dump.pool:
	ld	hl, (os.malloc.mp_start)
	
dump.pool.loop:
	call	zp.cscroll
	push	hl
	ld	hl, $0800
	ld	(os.curpos.col), hl
	pop	hl
	
	ld	d, (hl)
	inc	hl
	ld	e, (hl)
	inc	hl
	
	ld	a, $80
	and	d
	rlca
	add	a, '0'
	set	7, d
	
	push	de
	
	call	zp.cputch
	ld	a, ':'
	call	zp.cputch
	
	ex	de, hl
	or	a
	sbc	hl, de
	
	push	af
	
	ld	de, os.scrap
	call	zp.htoa_word
	xor	a
	ld	(de), a
	ld	hl, os.scrap
	call	zp.cprint
	
	pop	af
	pop	hl
	jr	z, $+4
	jr	nc, dump.pool.loop
	
	call zp.cdisp
	jp	zp.getch

; input : ahl -> chunk address
; output : bc -> chunk size
; destroys : none
vect_chunk_size:
	push	af
	ld	c, a
	in	a, (map_bankB_port)
	push	af
	ld	a, c
	out	(map_bankB_port), a
	
	push	hl
	push	de
	
	ld	d, (hl)
	inc	hl
	ld	e, (hl)
	inc	hl
	set	7, d
	or	a
	ex	de, hl
	sbc	hl, de
	
	jr	nc, $+6
	; This is the highest block and its size can't be determined from its link.
	ld	hl, - os.falloc.poolend
	add	hl, de
	
	ld	b, h
	ld	c, l
	pop	de
	pop	hl
	pop	af
	out	(map_bankB_port), a
	pop	af
	ret

;
; FILE structure (internal, subject to change) :
;
; {
;   byte : number of chunks
;   word : index of file pointer
;   byte + word : paged address of file pointer
;   (byte + word)+ : paged addresses of chunks
; }
;

; brief : Open a file and setup a FILE object to access it using high level file I/O API
; input : hl -> filename
; output : CF set on failure, hl -> FILE object pointer (allocated on heap)
; destroys : a, bc, de, ix, iy
vect_fopen:
	ld	de, 0
	ld	(os.fopen.out), de
	
	ld	ix, fopen.cb
	call	zp.file_find
	
	ld	hl, (os.fopen.out)
	
	ret

fopen.cb:
	push	de
	ld	bc, 9
	call	zp.malloc
	pop	de
	
	push	hl
	
	inc	de
	inc	de
	
	xor	a
	ld	(hl), 1
	inc	hl
	
	ld	(hl), a
	inc	hl
	ld	(hl), a
	inc	hl
	
	call	fopen.cb.initf
	jr	fopen.cb.skip
	
fopen.cb.loop:
	; realloc FILE object with bigger size
	pop	hl
	inc	bc
	inc	bc
	inc	bc
	call	zp.realloc
	push	hl
	; increase chunk counter in FILE object
	inc	(hl)
	; update storage pointer
	add	hl, bc
	dec	hl
	dec	hl
	dec	hl
fopen.cb.skip:
	; store a chunk pointer in FILE object
	call	fopen.cb.initf
	
	; check for last chunk
	ex	de, hl
	call	zp.file_nextchunk
	ex	de, hl
	
	; loop if needed
	jr	nc, fopen.cb.loop
	
	pop	hl
	ld	(os.fopen.out), hl
	
	ret

fopen.cb.initf:
	in	a, (map_bankB_port)
	
	ld	(hl), a
	inc	hl
	ld	(hl), e
	inc	hl
	ld	(hl), d
	inc	hl
	ret

; brief : close a file and release memory used by the FILE object
; input : hl -> pointer to FILE object
; output : none
; destroys : a, de, hl
vect_fclose:
	
	jp	zp.free

; brief : checks whether End Of File has been reached
; input : hl -> pointer to FILE object
; output : Z if EOF reached, Z otherwise
; destroys : a, bc, de
vect_feof:
	call	vect_ftell
	call	vect_fsize
	ex	de, hl
	cmp_hlbc
	ex	de, hl
	ret

; brief : compute the size of the data in a file
; input : hl -> pointer to FILE object
; output : CF set on failure, bc -> file size
; destroys : a
vect_fsize:
	ld	a, (hl)
	dec	a
	
	; beware : the following MUST NOT affect the Zero flag
	push	hl
	ld	bc, 6
	add	hl, bc
	ld	a, (hl)
	inc	hl
	ld	c, (hl)
	inc	hl
	ld	h, (hl)
	ld	l, c
	
	jr	z, vect_fsize.nosplit
	; multiple chunks : use meta_SIZE field
	ld	c, a
	in	a, (map_bankB_port)
	push	af
	ld	a, c
	out	(map_bankB_port), a
	
	inc	hl
	inc	hl
	push	de
	ld	d, meta_SIZE
	call	zp.file_meta_find
	pop	de
	pop	bc
	
	push	af
	add	a, 2
	offset_hl
	pop	af
	
	ld	a, b
	
	; todo : iterate over chunks if size field missing?
	jr	c, $+5
	
	ld	c, (hl)
	inc	hl
	ld	b, (hl)
	
	out	(map_bankB_port), a
	pop	hl
	ret
	
vect_fsize.nosplit:
	; single chunk : get chunk size
	call	vect_chunk_size
	or	a
	pop	hl
	ret

; brief : resizes a file
; input : hl -> pointer to FILE object, bc -> new size
; output : none
; destroys : 
vect_fresize:
	push	bc
	call	vect_fsize
	pop	de
	ex	de, hl
	or	a
	sbc	hl, bc
	ex	de, hl
	jr	c, vect_fgrow
	
vect_fshrink:
	; need to remove de bytes from end
	push	hl
	
	; todo...
	
	pop	hl
	ret

vect_fgrow:
	; need to add -de bytes at end
	
	push	hl
	ld	a, (hl)
	add	a, 2
	ld	c, a
	add	a, a
	add	a, c
	offset_hl
	
	ld	a, (hl)
	inc	hl
	push	hl
	ld	c, (hl)
	inc	hl
	ld	h, (hl)
	ld	l, c
	
	call	vect_chunk_size
	push	hl
	ld	hl, 0
	or	a
	sbc	hl, de
	add	hl, bc
	ld	b, h
	ld	c, l
	pop	hl
	inc	hl
	inc	hl
	call	zp.realloc
	
	; todo : handle failure more gracefully...
	call	c, zp.throw_memory
	
	pop	de
	ex	de, hl
	ld	(hl), e
	inc	hl
	ld	(hl), d
	
	pop	hl
	ret

; brief : set the file data pointer to a given position
; input : hl -> pointer to FILE object, de -> offset in file
; output : none
; destroys : 
; note :
vect_fseek:
	call	vect_fsize
	ex	de, hl
	cmp_hlbc
	ex	de, hl
	
	; beyond boundaries :fail (set to end instead???)
	;ret	c
	ld	d, b
	ld	e, c
	
vect_fseek.unsafe:
	ld	a, (hl)
	
	; update file offset
	inc	hl
	ld	(hl), e
	inc	hl
	ld	(hl), d
	
	inc	hl
	push	hl
	inc	hl
	inc	hl
	
	;ld	bc, 5
	;add	hl, bc
	
	ld	c, 0
	
vect_fseek.loop:
	push	af
	
	push	bc
	
	; get chunk size
	inc	hl
	ld	a, (hl)
	inc	hl
	ld	c, (hl)
	inc	hl
	push	hl
	ld	h, (hl)
	ld	l, c
	call	vect_chunk_size
	pop	hl
	
	ex	(sp), hl
	add	hl, bc
	
	; hl now holds cumulated chunk size
	; if de (seek offset) is strictly less than that we've reached the proper block
	ex	de, hl
	cmp_hlde
	ex	de, hl
	
	jr	c, vect_fseek.found
	
	; update bc (cumulated size) and get back hl (pointer to next chunk address)
	ld	b, h
	ld	c, l
	pop	hl
	
	pop	af
	dec	a
	jr	nz, vect_fseek.loop
	
	; this code should be *dead*
	jr	vect_fseek.end

vect_fseek.found:
	; compute chunk offset
	or	a
	sbc	hl, bc
	ex	de, hl
	sbc	hl, de
	ex	de, hl
	
	pop	hl
	
	; get back chunk address
	ld	b, (hl)
	dec	hl
	ld	c, (hl)
	dec	hl
	ld	a, (hl)
	
	; compute chunk pointer
	ex	de, hl
	add	hl, bc
	ex	de, hl
	
	pop	hl
	
	; set file pointer
	push	hl
	ld	(hl), a
	inc	hl
	ld	(hl), e
	inc	hl
	ld	(hl), d
	
vect_fseek.end:
	pop	hl
	
	dec	hl
	dec	hl
	dec	hl
	ret

; brief : get the position of the file data pointer
; input : hl -> pointer to FILE object
; output : de -> offset in file
; destroys : none
vect_ftell:
	inc	hl
	ld	e, (hl)
	inc	hl
	ld	d, (hl)
	dec	hl
	dec	hl
	ret

; brief : read a chunk of data from a file
; input : hl -> pointer to FILE object, bc -> size of chunk, de -> buffer
; output : de -> end of buffer (de += bc)
; destroys : a, bc
vect_fread:
	dec	bc
	ld	a, b
	ld	b, c
	ld	c, a
	inc	b
	inc	c

vect_fread.loop:
	push	de
	push	bc
	call	vect_fgetc
	pop	bc
	pop	de
	ld	(de), a
	inc	de
	djnz	vect_fread.loop
	dec	c
	jr	nz, vect_fread.loop
	
	ret

; brief : write a chunk of data to a file
; input : hl -> pointer to FILE object, bc -> size of chunk, de -> buffer
; output : de -> end of buffer (de += bc)
; destroys : a, bc
vect_fwrite:
	dec	bc
	ld	a, b
	ld	b, c
	ld	c, a
	inc	b
	inc	c

vect_fwrite.loop:
	ld	a, (de)
	inc	de
	push	bc
	push	de
	call	vect_fputc
	pop	de
	pop	bc
	djnz	vect_fwrite.loop
	dec	c
	jr	nz, vect_fwrite.loop
	
	ret

; brief : read a character (byte) from a file
; input : hl -> pointer to FILE object
; output : CF set if EOF reached, a -> character
; destroys : de
vect_fgetc:
	call	vect_feof
	jr	nz, vect_fgetc.unsafe
	scf
	ret
vect_fgetc.unsafe:
	push	bc
	in	a, (map_bankB_port)
	push	af
	
	push	hl
	inc	hl
	inc	hl
	inc	hl
	ld	a, (hl)
	inc	hl
	ld	e, (hl)
	inc	hl
	ld	d, (hl)
	out	(map_bankB_port), a
	ld	a, (de)
	pop	hl
	
	pop	af
	out	(map_bankB_port), a
	
	call	vect_ffwd
	
	ld	a, c
	pop	bc
	
	or	a
	ret

; brief : write a character (byte) from file
; input : hl -> pointer to FILE object, a -> character
; output : none
; destroys : a, de
vect_fputc:
	call	vect_feof
	jr	nz, vect_fputc.unsafe
	; make room for the byte
	
	; weird huh? that's the price of short-circuiting...
	; this will make the file grow by one byte
	; (todo : make more room to areduce the number of grow
	; in case caller is too stupid to reserve memory himself...)
	ld	de, -1
	call	vect_fgrow
	
vect_fputc.unsafe:
	push	bc
	ld	c, a
	in	a, (map_bankB_port)
	push	af
	
	push	hl
	inc	hl
	inc	hl
	inc	hl
	ld	a, (hl)
	inc	hl
	ld	e, (hl)
	inc	hl
	ld	d, (hl)
	out	(map_bankB_port), a
	ex	de, hl
	ld	(hl), c
	pop	hl
	
	pop	af
	out	(map_bankB_port), a
	
	call	vect_ffwd
	
	pop	bc
	ret

; brief : moves file pointer one byte forward
; input : hl -> pointer to FILE object
; output : none
; destroys :
vect_ffwd:
	
	
	
	ret

vat.test:
	call	load
	ret	c
	call	vect_fsize
	push	hl
	call	zp.malloc
	ld	(vat_loc), hl
	ex	de, hl
	pop	hl
	call	vect_fread
	
	; do something with that VAT
	
	
	; save it back to file...
	ld	bc, 
	push	bc
	call	vect_fresize
	ld	de, 0
	call	vect_fseek
	ld	de, (vat_loc)
	pop	bc
	call	vect_fwrite
	jp	save

load:
	ld	hl, vat_dump
	call	vect_fopen
	ld	(vat_FILE), hl
	ret	nc
	ld	hl, vat_dump
	ld	bc, 
	call	zp.file_create
	jr	nc, load
	ret

save:
	ld	hl, (vat_FILE)
	ld	bc, 
	call	vect_fresize
	
	ld	de, 
	call	vect_fwrite
	jp	vect_fclose

vat_loc:
	.dw 0

vat_FILE:
	.dw	0

vat_dump:
	.db "compat-vat", 0

.end