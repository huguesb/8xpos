.nolist
;Copyright (c) 2009, Luc BRUANT aka fullmetalcoder.
;Redistribution and use in source and binary forms, with or without modification, are
;permitted provided that the following conditions are met:
;Redistributions of source code must retain the above copyright notice, this list of
;conditions and the following disclaimer.
;
;Redistributions in binary form must reproduce the above copyright notice, this list of
;conditions and the following disclaimer in the documentation and/or other materials
;provided with the distribution.
;
;THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
;"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
;TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
;PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
;CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
;EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
;PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
;PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
;OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
;NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
;SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
.list

;
; dynamic library framework
;
; goal : make it possible to create dynamic library and use them in programs
;

;
; calling convention should be as fast as possible
; any programming "burden" must be avoided in regular app programming but some
; might be necessary for DLL programming (code must be somewhat position independent)
;

;
; preliminary design choices:
;	* jump table at the beginning of caller app (macros)
;	* reloc table at the beginning of each library file :
;		Each entry is a 16 bit offset (relative to lib start ie before the reloc table)
;		pointing to a 16 bit address that must be updated ( *entry += load_address - dylib_header_size ).
;		The table must be generated by hand as shown in the example below.
;	* libs may be loaded anywhere in program memory ($4000-$BFFF) [though not where
;	there is some program code...]
;	* upon lib load the code is copied and all the entries of the reloc table are
;	processed
;

; ;
; ; sample lib source :
; ;
; .org $0000
; 	.db magic.dynamiclib
; lib_name:
; 	.db "mylib", 0
; 
; ; major, minor, patch
; version:
; 	.db 1, 0, 0
;
; header_size:
; 	.dw reloc_data_end - reloc_table
;
; ; reloc table
; reloc_table:
; 	; number of entries
; 	.dw	4
; 	
; 	; entries
; 	.dw	reloc_1
; 	.dw	reloc_2
; 	.dw	reloc_3
; 	.dw	reloc_4
; 
; ; vector table, entries are automatically relocated, no need to add extra reloc entries for these values 
; vector_table:
; 	; number of entries
; 	.dw	3
; 	
; 	; entries
; 	.dw	routine_a
; 	.dw	routine_b
; 	.dw	routine_c
;
; reloc_data_end:
;
; code_size:
; 	.dw code_end - code_start
; 
; code_start:
; routine_a:
; 	; ...
; reloc_1 = $+1
; 	call	routine_b
; 	; ...
; reloc_2 = $+1
; 	call	routine_b
; 	; ...
; 	ret
; 
; routine_b:
; 	; ...
; reloc_3 = $+1
; 	call	routine_c
; 	; ...
; 	ret
; 
; routine_c:
; 	; ...
; reloc_4 = $+1
; 	jp	routine_a
;
; code_end:
;

; brief : load a library
; input : hl -> pointer to lib spec (name, version requirement, jump table)
; ouptut : CF set on failure, reset on success
; destroys : a, bc, de, hl, ix, iy
; warning : lib spec MUST NOT be (even partly) in the $8000-$BFFF range !!!
; note : uses the first 8 bytes of os.scrap as temporary storage
vect_dylib_load:
	push	hl
	pop	iy
	
	ld	c, fmask( bitmask(list_alloc) )
	ld	ix, vect_dylib_load.cb
	call	zp.file_list
	
	ccf
	ret

vect_dylib_load.cb.notfound:
	or	a
	ret

vect_dylib_load.cb:
	; hl -> data (metadata)
	; de -> size (node)
	; iy -> lib spec pointer
	
	; keep access to metadata for code copy (in case of split file)
	ld	(os.scrap), hl
	
	; skip metadata and TIOS file size field
	ld	b, 0
	ld	c, (hl)
	inc	bc
	inc	bc
	inc	bc
	add	hl, bc
	ex	de, hl
	or	a
	sbc	hl, bc
	; store segment size for copy
	ld	(os.scrap + 4), hl
	ex	de, hl
	; store segment start for reloc computations
	ld	(os.scrap + 2), hl
	
	; get back lib spec pointer
	push	iy
	pop	de
	
	; check for lib file
	ld	a, (hl)
	inc	hl
	
	cp	magic.dynamiclib
	jr	nz, vect_dylib_load.cb.notfound
	
	; check for matching name
	call	vect_strcmp_end
	jr	nz, vect_dylib_load.cb.notfound
	
	; lib found : version check
	
	; version check
	push	bc
	push	hl
	push	de
	ld	hl, version_rels
	call	zp.findstr
	ld	a, c
	pop	de
	pop	hl
	pop	bc
	; invalid version request...
	jr	nz, vect_dylib_load.cb.notfound
	push	af
	ex	de, hl
	call	zp.strend
	pop	af
	
	call	zp.version_check
	ex	de, hl
	
	jr	c, vect_dylib_load.cb.notfound
	
	push	iy
	
	push	de
	
	; get reloc data size
	ld	c, (hl)
	inc	hl
	ld	b, (hl)
	inc	hl
	
	; alloc some space to store it
	push	bc
	push	hl
	call	zp.malloc
	ld	(os.scrap + 6), hl
	ex	de, hl
	pop	hl
	pop	bc
	
	; copy reloc data to allocated memory
	ldir
	
	; get code size
	ld	c, (hl)
	inc	hl
	ld	b, (hl)
	inc	hl
	
	ex	de, hl
	ld	hl, (os.scrap + 2)
	or	a
	sbc	hl, de
	ex	de, hl
	
	; de = -full_header_size
	
	; alloc lib slot in prog space (result in de)
	push	hl
	push	de
	call	vect_dylib_alloc_slot
	pop	bc
	pop	hl
	
	; prepare reloc base
	push	de
	pop	iy
	add	iy, bc
; 	call	__dump_de
; 	call	__dump_iy
	
	push	hl
	; get back and correct segment size
	ld	hl, (os.scrap + 4)
	add	hl, bc
	ld	b, h
	ld	c, l
	pop	hl
	
; 	call	__dump_hl
; 	call	__dump_de
; 	call	__dump_bc
	
	call	vect_dylib_copy_code
	
	pop	de
	; relocations
	
	; instead of swapping page on demand, always
	; swap page around prog space write since it
	; is not interlaced with fs read
	in	a, (map_bankB_port)
	push	af
	; warning : keep consistent with run.z80
	ld	a, $83
	out	(map_bankB_port), a
	
	push	de
	
	ld	hl, (os.scrap + 6)
	
	ld	c, (hl)
	inc	hl
	ld	b, (hl)
	inc	hl
	
; 	call	__dump_hl
; 	call	__dump_bc
	
	call	vect_dylib_relocate
	
	;ld	c, (hl)
	inc	hl
	;ld	b, (hl)
	inc	hl
	ex	de, hl
	
	pop	hl
	ld	c, (hl)
	inc	hl
	ld	b, (hl)
	inc	hl
	deref_hl
	
; 	call	__dump_hl
; 	call	__dump_de
; 	call	__dump_bc
	
	call	vect_dylib_update_jump
	
	ld	hl, (os.scrap + 6)
	call	zp.free
	
	pop	af
	out	(map_bankB_port), a
	
	pop	iy
	ret

; input : bc -> required size of lib slot
; output : de -> address of lib slot
; destroys : a, bc, hl
; note : throws exception if no slot of suitable size is found
vect_dylib_alloc_slot:
	; save fs page
	in	a, (map_bankB_port)
	push	af
	; map 2nd prog space page
	; warning : keep consistent with run.z80
	ld	a, $83
	out	(map_bankB_port), a
	pop	af
	
	push	bc
	
	; find a free lib slot of proper size
	ld	hl, (psp.libs)
	ld	de, $C000
	
	; skip previously loaded libs
vect_dylib_alloc_slot.loop:
	; check for lib section end
	cmp_hlde
	jr	nc, vect_dylib_alloc_slot.mem
	
	ld	c, (hl)
	inc	hl
	ld	b, (hl)
	inc	hl
	
	; check for occupied
	bit	7, b
	res	7, b
	jr	nz, vect_dylib_alloc_slot.occ
	
	; see if the lib to load can fit in this slot
	
	; todo : handle split files...
	ex	(sp), hl
	cmp_hlbc
	ex	(sp), hl
	jr	c, vect_dylib_alloc_slot.ok
	
vect_dylib_alloc_slot.occ:
	; move to next slot
	add	hl, bc
	jr	vect_dylib_alloc_slot.loop
	
vect_dylib_alloc_slot.mem:
	; fail : no big enough chunk of memory available in libs
	; section to load this library..
	
	; restore fs page.
	out	(map_bankB_port), a
	
	; throw exception
	call	zp.throw_memory
	
	ret
	
vect_dylib_alloc_slot.ok:
	; load !!!
	
	pop	bc
	push	af
	
	ld	e, (hl)
	inc	hl
	ld	d, (hl)
	dec	hl
	
	ex	de, hl
	or	a
	sbc	hl, bc
	
	; check for min size (to determine whether to split slot
	ld	a, l
	and	$E0
	or	h
	
	jr	z, vect_dylib_alloc_slot.nosplit
	; split block
	ex	de, hl
	add	hl, bc
	
	ld	(hl), e
	inc	hl
	ld	(hl), d
	dec	hl
	or	a
	sbc	hl, bc
	
	ex	de, hl
	jr	vect_dylib_alloc_slot.splitend
	
vect_dylib_alloc_slot.nosplit:
	; do not split block
	add	hl, bc
	ld	b, h
	ld	c, l
	
vect_dylib_alloc_slot.splitend:
	; update lib slot (size and occupation status bit)
	ex	de, hl
	set	7, b
	ld	(hl), c
	inc	hl
	ld	(hl), b
	inc	hl
	ex	de, hl
	
	pop	af
	
	; restore fs page
	out	(map_bankB_port), a
	
	ret

; brief : ldir with support for paging subtilities
vect_dylib_copy_code:
	in	a, (map_bankB_port)
	push	af
	
	in	a, (map_bankA_port)
	push	af
	
vect_dylib_copy_code.loop:
	bit	7, d
	jr	z, vect_dylib_copy_code.noswap
	; note : assume called from userspace prog loaded in pages $81 and $83
	; warning : keep consistent with run.z80
	ld	a, $83
	out	(map_bankA_port), a
	; correct destination
	push	bc
	ld	bc, $4000
	ex	de, hl
	or	a
	sbc	hl, bc
	ex	de, hl
	pop	bc
vect_dylib_copy_code.noswap:
	ldi
	jp	pe, vect_dylib_copy_code.loop
	
	; check for more file data here...
	push	de
	ld	hl, (os.scrap)
	call	zp.file_nextchunk
	pop	de
	jr	c, vect_dylib_copy_code.end
	
	; preserve copy destination
	push	de
	
	; get node content size
	dec	hl
	dec	hl
	call	zp.file_node_info
	
	; skip metadata
	ld	b, 0
	ld	c, (hl)
	inc	bc
	add	hl, bc
	ex	de, hl
	or	a
	sbc	hl, bc
	ex	de, hl
	ld	b, d
	ld	c, e
	
	pop	de
	
	jr	vect_dylib_copy_code.loop
	
vect_dylib_copy_code.end:
	pop	af
	out	(map_bankA_port), a
	
	pop	af
	out	(map_bankB_port), a
	
	ret

; hl -> reloc table
; bc -> reloc table entry count
; iy -> reloc base
vect_dylib_relocate:
	; get reloc offset [sys]
	ld	e, (hl)
	inc	hl
	ld	d, (hl)
	inc	hl
	
	; perform relocation [prog]
	push	hl
	push	iy
	pop	hl
	add	hl, de
	
	ld	a, iyl
	add	a, (hl)
	ld	(hl), a
	ld	a, iyh
	inc	hl
	adc	a, (hl)
	ld	(hl), a
	pop	hl
	
	dec	bc
	ld	a, b
	or	c
	jr	nz, vect_dylib_relocate
	
	ret

; hl -> jump table
; de -> vector table
; bc -> jump table entry count
; iy -> reloc base
vect_dylib_update_jump:
	push	bc
	
	; get vector offset [prog]
	inc	hl
	ld	c, (hl)
	inc	hl
	ld	b, (hl)
	dec	hl
	
	; get corresponding PIC offset [sys]
	push	de
	ex	de, hl
	add	hl, bc
	add	hl, bc
	deref_hl
	ld	b, h
	ld	c, l
	ex	de, hl
	pop	de
	
	; perform relocation [prog]
	push	iy
	add	iy, bc
	ld	a, iyl
	ld	(hl), a
	inc	hl
	ld	a, iyh
	ld	(hl), a
	inc	hl
	pop	iy
	
	pop	bc
	dec	bc
	ld	a, b
	or	c
	jr	nz, vect_dylib_update_jump
	
	ret
	
vect_dylib_unload:
	
	ret

; careful not to change the order without updating version_check routine
version_rels:
	.db ">", 0
	.db "<", 0
	.db ">=", 0
	.db "<=", 0
	.db "=", 0
	.db 0


; brief : 
; input : a -> version relation, hl -> address of requested version, de -> address of vailable version
; output : CF set on failure, reset on success ( de [a] hl ), hl += 3, de += 3
; destroys : a
vect_version_check:
	; relation bounds checking
	cp	5
	jr	nc, vect_version_check.error
	
	; jump to proper check
	push	hl
	ld	hl, vect_version_check.jump
	add	a, a
	offset_hl
	deref_hl
	ex	(sp), hl
	ret

vect_version_check.error:
	inc	hl
	inc	de
vect_version_check.e2:
	inc	de
	inc	hl
vect_version_check.e1:
	inc	de
	inc	hl
vect_version_check.e0:
	scf
	ret

vect_version_check.jump:
	.dw	vect_version_check.gt
	.dw	vect_version_check.lt
	.dw	vect_version_check.ge
	.dw	vect_version_check.le
	.dw	vect_version_check.eq

vect_version_check.gt:
	; req : *de > *hl
	
	ex	de, hl
	ld	a, (de)
	inc	de
	cp	(hl)
	inc	hl
	ex	de, hl
	jr	nc, vect_version_check.e2
	
	ex	de, hl
	ld	a, (de)
	inc	de
	cp	(hl)
	inc	hl
	ex	de, hl
	jr	nc, vect_version_check.e1
	
	ex	de, hl
	ld	a, (de)
	inc	de
	cp	(hl)
	inc	hl
	ex	de, hl
	jr	nc, vect_version_check.e0
	
	or	a
	ret
	
vect_version_check.lt:
	; req : *de < *hl
	
	ld	a, (de)
	inc	de
	cp	(hl)
	inc	hl
	jr	nc, vect_version_check.e2
	
	ld	a, (de)
	inc	de
	cp	(hl)
	inc	hl
	jr	nc, vect_version_check.e1
	
	ld	a, (de)
	inc	de
	cp	(hl)
	inc	hl
	jr	nc, vect_version_check.e0
	
	or	a
	ret
	
vect_version_check.ge:
	; req : *de >= *hl
	
	call	vect_version_check.lt
	ccf
	ret
	
vect_version_check.le:
	; req : *de <= *hl
	
	call	vect_version_check.gt
	ccf
	ret
	
vect_version_check.eq:
	ld	a, (de)
	inc	de
	cp	(hl)
	inc	hl
	jr	nz, vect_version_check.e2
	
	ld	a, (de)
	inc	de
	cp	(hl)
	inc	hl
	jr	nz, vect_version_check.e1
	
	ld	a, (de)
	inc	de
	cp	(hl)
	inc	hl
	jr	nz, vect_version_check.e0
	
	or	a
	ret
	
; brief : load a list of libraries
; input : hl -> pointer to list of pointers to spec (length prefixed)
; ouptut : none
; destroys :
vect_dylib_load_all:
	ld	b, (hl)
	
	ld	a, b
	or	a
	ret	z
	
	inc	hl
	
vect_dylib_load_all.loop:
	push	bc
	push	hl
	deref_hl
	call	vect_dylib_load
	pop	hl
	pop	bc
	inc	hl
	inc	hl
	djnz	vect_dylib_load_all.loop
	
	ret

; brief : unload all libraries loaded in a program
; input : none
; ouptut : none
; destroys :
vect_dylib_unload_all:
	ld	hl, (psp.libs)
	
	
	ld	(hl), 0
	ret

