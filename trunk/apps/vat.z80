.nolist
; Copyright (c) 2009, Luc BRUANT aka fullmetalcoder.
;Redistribution and use in source and binary forms, with or without modification, are
;permitted provided that the following conditions are met:
;Redistributions of source code must retain the above copyright notice, this list of
;conditions and the following disclaimer.
;
;Redistributions in binary form must reproduce the above copyright notice, this list of
;conditions and the following disclaimer in the documentation and/or other materials
;provided with the distribution.
;
;THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
;"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
;TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
;PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
;CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
;EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
;PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
;PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
;OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
;NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
;SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
.list

.nolist
; OS config file
#include "xos.inc"
; syscalls addresses
#include "xos.exp"
; library header file
#include "apps/gui.inc"
.list

#define t_dump call dump.pool

#define t_malloc(n,sz) ld bc, sz \ call zp.malloc \ ld (n*2 + slots), hl \ t_dump
#define t_free(n) ld hl, (n*2 + slots) \ call zp.free \ t_dump
#define t_realloc(n,sz) ld hl, (n*2 + slots) \ ld bc, sz \ call zp.realloc \ ld (n*2 + slots), hl \ t_dump

.org	prgm.start - 2
	.db magic.executable, 0
	
	
fileio.test:
	or	a
	ret	z
	
	call	zp.fopen
	ret	c
	ld	(fptr), hl
	
	call	dump.filehandle
	
; 	call	vect_fsize
; 	push	hl
; 	ld	de, os.scrap
; 	ld	h, b
; 	ld	l, c
; 	call	zp.htoa_word
; 	xor	a
; 	ld	(de), a
; 	ld	hl, os.scrap
; 	call	zp.cputs
; 	call	zp.cdisp
; 	call	zp.getch
; 	pop	hl
	
	ld	de, $0380
	call	vect_fseek
	
	;call	dump.filehandle
	
	call	vect_ftell
	ex	de, hl
	call	dump_hl
	ex	de, hl
	
	ld	de, os.scrap
	ld	bc, $50
	call	vect_fread
	
	push	hl
	ld	hl, os.scrap
	ld	de, os.console
	ld	b, $50
	call	zp.memdump
	inc	hl
	djnz	$-4
	call	zp.cdisp
	call	zp.getch
	pop	hl
	
	ld	hl, (fptr)
	call	zp.fclose
	ret

fptr:
	.dw	0

; 	; first test malloc/free/realloc
; malloc.test:
; 	
; 	t_malloc(0, $0100)
; 	t_malloc(1, $0100)
; 	t_malloc(2, $0100)
; 	t_malloc(3, $0100)
; 	t_free(1)
; 	t_free(2)
; 	t_malloc(1, $0200)
; 	t_realloc(0, $0200)
; 	t_free(3)
; 	t_realloc(1, $0300)
; 	
; 	t_free(1)
; 	t_free(0)
; 	
; 	ret
; 
; slots:
; 	.dw 0, 0, 0, 0

dump_hl:
	push	af
	push	de
	push	hl
	push	bc
	
	ld	de, os.scrap + 16
	call	zp.htoa_word
	ld	a, '@'
	ld	(de), a
	inc	de
	ld	hl, 8
	add	hl, sp
	deref_hl
	dec	hl
	dec	hl
	dec	hl
	call	zp.htoa_word
	xor	a
	ld	(de), a
	ld	hl, os.scrap + 16
	call	zp.cputs
	call	zp.cdisp
	call	zp.getch
	pop	bc
	pop	hl
	pop	de
	pop	af
	ret

dump.pool:
	ld	hl, (os.malloc.mp_start)
	
dump.pool.loop:
	call	zp.cscroll
	push	hl
	ld	hl, $0800
	ld	(os.curpos.col), hl
	pop	hl
	
	ld	d, (hl)
	inc	hl
	ld	e, (hl)
	inc	hl
	
	ld	a, $80
	and	d
	rlca
	add	a, '0'
	set	7, d
	
	push	de
	
	call	zp.cputch
	ld	a, ':'
	call	zp.cputch
	
	ex	de, hl
	or	a
	sbc	hl, de
	
	push	af
	
	ld	de, os.scrap
	call	zp.htoa_word
	xor	a
	ld	(de), a
	ld	hl, os.scrap
	call	zp.cprint
	
	pop	af
	pop	hl
	jr	z, $+4
	jr	nc, dump.pool.loop
	
	call zp.cdisp
	jp	zp.getch

dump.filehandle:
	ld	a, (hl)
	inc	a
	ld	b, a
	inc	a
	add	a, a
	add	a, b
	ld	b, a
	ld	de, os.console
	
	push	hl
	call	zp.memdump
	inc	hl
	djnz	$-4
	
	call	zp.cdisp
	call	zp.getch
	pop	hl
	
	ret

; brief : checks whether End Of File has been reached
; input : hl -> pointer to FILE object
; output : CF reset if EOF reached, set otherwise
; destroys : a, bc, de
vect_feof:
	push	hl
	ld	a, (hl)
	inc	hl
	inc	hl
	ld	e, (hl)
	inc	hl
	ld	d, (hl)
	inc	hl
	cp	(hl)
	jr	nz, vect_feof.no
	
	inc	hl
	ld	c, a
	add	a, a
	add	a, c
	ld	c, a
	add	hl, bc
	
	push	de
	
	ld	a, (hl)
	inc	hl
	ld	e, (hl)
	inc	hl
	ld	d, (hl)
	
	ex	de, hl
	
	pop	de
	
	call	zp.chunk_atend
	pop	hl
	ret

vect_feof.no:
	pop	hl
	scf
	ret

; brief : compute the size of the data in a file
; input : hl -> pointer to FILE object
; output : CF set on failure, bc -> file size
; destroys : a
vect_fsize:
	ld	a, (hl)
	dec	a
	
	; beware : the following MUST NOT affect the Zero flag
	push	hl
	ld	bc, 5
	add	hl, bc
	ld	a, (hl)
	inc	hl
	ld	c, (hl)
	inc	hl
	ld	h, (hl)
	ld	l, c
	
	jr	z, vect_fsize.nosplit
	; multiple chunks : use meta_SIZE field
	ld	c, a
	in	a, (map_bankB_port)
	push	af
	ld	a, c
	out	(map_bankB_port), a
	
	inc	hl
	inc	hl
	push	de
	ld	d, meta_SIZE
	call	zp.file_meta_find
	pop	de
	pop	bc
	
	push	af
	add	a, 2
	offset_hl
	pop	af
	
	ld	a, b
	
	; todo : iterate over chunks if size field missing?
	;jr	c, $+5
	
	ld	c, (hl)
	inc	hl
	ld	b, (hl)
	
	out	(map_bankB_port), a
	pop	hl
	ret
	
vect_fsize.nosplit:
	; single chunk : get chunk size
	push	de
	call	zp.chunk_size
	pop	de
	
	or	a
	pop	hl
	ret

; brief : resizes a file
; input : hl -> pointer to FILE object, bc -> new size
; output : none
; destroys : 
vect_fresize:
	push	bc
	call	vect_fsize
	pop	de
	ex	de, hl
	or	a
	sbc	hl, bc
	ex	de, hl
	jr	c, vect_fgrow
	
vect_fshrink:
	; need to remove de bytes from end
	push	hl
	
	; todo...
	
	pop	hl
	ret

vect_fgrow:
	; need to add -de bytes at end
	
	push	hl
	ld	a, (hl)
	ld	c, a
	inc	a
	add	a, a
	add	a, c
	offset_hl
	
	ld	a, (hl)
	inc	hl
	push	hl
	ld	c, (hl)
	inc	hl
	ld	h, (hl)
	ld	l, c
	
	push	de
	call	zp.chunk_size
	pop	de
	
	push	hl
	ld	hl, 0
	or	a
	sbc	hl, de
	add	hl, bc
	ld	b, h
	ld	c, l
	pop	hl
	
	inc	hl
	inc	hl
	call	zp.realloc
	dec	hl
	dec	hl
	
	; todo : handle failure more gracefully...
	call	c, zp.throw_memory
	
	pop	de
	ex	de, hl
	ld	(hl), e
	inc	hl
	ld	(hl), d
	
	pop	hl
	ret

; brief : set the file data pointer to a given position
; input : hl -> pointer to FILE object, de -> offset in file
; output : none
; destroys : 
; note :
vect_fseek:
	push	hl
	ld	a, (hl)
	
	ld	bc, 4
	add	hl, bc
	
	ld	c, 0
	
vect_fseek.loop:
	push	af
	
	push	bc
	
	; get chunk size
	inc	hl
	ld	a, (hl)
	inc	hl
	ld	c, (hl)
	inc	hl
	push	hl
	ld	h, (hl)
	ld	l, c
	push	de
	call	zp.chunk_size
	pop	de
	pop	hl
	
	ex	(sp), hl
	add	hl, bc
	
	; hl now holds cumulated chunk size
	; if de (seek offset) is strictly less than that we've reached the proper block
	ex	de, hl
	cmp_hlde
	ex	de, hl
	
	jr	c, vect_fseek.found
	
	; update bc (cumulated size) and get back hl (pointer to next chunk address)
	ld	b, h
	ld	c, l
	pop	hl
	
	pop	af
	dec	a
	jr	nz, vect_fseek.loop
	
	;;;; this code should be *dead*
	; todo : set file poitner to EOF
	
	jr	vect_fseek.end

vect_fseek.found:
	; compute chunk offset
	or	a
	sbc	hl, bc
	ex	de, hl
	or	a
	sbc	hl, de
	ex	de, hl
	
	pop	hl
	
	; get back chunk address
	ld	b, (hl)
	dec	hl
	ld	c, (hl)
	dec	hl
	inc	bc
	inc	bc
	
	in	a, (map_bankB_port)
	push	af
	ld	a, (hl)
	out	(map_bankB_port), a
	
	; metadata adjust
	ld	a, (bc)
	inc	bc
	offset_bc
	
	; compute file pointer
	ex	de, hl
	add	hl, bc
	ex	de, hl
	
	pop	af
	out	(map_bankB_port), a
	
	ld	b, (hl)
	pop	af
	
	pop	hl
	
	; compute chunk index
	neg
	add	a, (hl)
	
	; set file pointer
	push	hl
	
	inc	hl
	
	; update file pointer
	ld	(hl), b
	inc	hl
	ld	(hl), e
	inc	hl
	ld	(hl), d
	inc	hl
	
	; update chunk index
	ld	(hl), a
	
vect_fseek.end:
	pop	hl
	ret

; brief : get the position of the file data pointer
; input : hl -> pointer to FILE object
; output : de -> offset in file
; destroys : a, bc
vect_ftell:
	push	hl
	
	ld	bc, 4
	add	hl, bc
	
	ld	b, (hl)
	ld	de, 0
	
	ld	a, b
	or	a
	jr	z, vect_ftell.skip
	
	push	de
	
vect_ftell.loop:
	inc	hl
	ld	a, (hl)
	inc	hl
	ld	e, (hl)
	inc	hl
	ld	d, (hl)
	
	push	hl
	ex	de, hl
	call	zp.chunk_size
	pop	hl
	ex	(sp), hl
	add	hl, bc
	ex	(sp), hl
	
	djnz	vect_ftell.loop
	
	pop	de
	
vect_ftell.skip:
	
	inc	hl
	ld	b, (hl)
	inc	hl
	ld	c, (hl)
	inc	hl
	
	; tricky shit : the metadata size must be retrieved from the fs page without scrambling registers...
	in	a, (map_bankB_port)
	push	af
	ld	a, b
	out	(map_bankB_port), a
	
	ld	b, (hl)
	
	; metadata adjust
	inc	bc
	inc	bc
	ld	a, (bc)
	inc	bc
	offset_bc
	
	pop	af
	out	(map_bankB_port), a
	
	pop	hl
	
	push	hl
	inc	hl
	inc	hl
	ld	a, (hl)
	inc	hl
	ld	h, (hl)
	cpl
	ld	l, a
	ld	a, h
	cpl
	inc	hl
	add	hl, bc
	add	hl, de
	ex	de, hl
	pop	hl
	ret

; brief : read a chunk of data from a file
; input : hl -> pointer to FILE object, bc -> size of chunk, de -> buffer
; output : CF set if reading ended prematurely due to EOF being reached, de -> end of buffer (de += bc)
; destroys : a, bc
vect_fread:
	dec	bc
	ld	a, b
	ld	b, c
	ld	c, a
	inc	b
	inc	c

vect_fread.loop:
	push	de
	call	vect_fgetc
	pop	de
	ld	(de), a
	inc	de
	ret	c
	djnz	vect_fread.loop
	dec	c
	jr	nz, vect_fread.loop
	
	ret

; brief : write a chunk of data to a file
; input : hl -> pointer to FILE object, bc -> size of chunk, de -> buffer
; output : de -> end of buffer (de += bc)
; destroys : a, bc
vect_fwrite:
	dec	bc
	ld	a, b
	ld	b, c
	ld	c, a
	inc	b
	inc	c

vect_fwrite.loop:
	ld	a, (de)
	inc	de
	push	de
	call	vect_fputc
	pop	de
	djnz	vect_fwrite.loop
	dec	c
	jr	nz, vect_fwrite.loop
	
	ret

; brief : read a character (byte) from a file
; input : hl -> pointer to FILE object
; output : CF set if EOF reached, a -> character
; destroys : de
vect_fgetc:
	call	vect_feof
	jr	nz, vect_fgetc.unsafe
	scf
	ret
vect_fgetc.unsafe:
	push	bc
	
	in	a, (map_bankB_port)
	push	af
	
	push	hl
	inc	hl
	
	ld	a, (hl)
	inc	hl
	ld	e, (hl)
	inc	(hl)
	inc	hl
	ld	d, (hl)
	jr	nz, $+3
	inc	(hl)
	inc	hl
	ld	c, (hl)
	inc	hl
	
	out	(map_bankB_port), a
	
	ld	b, 0
	add	hl, bc
	add	hl, bc
	add	hl, bc
	
	ld	a, (hl)
	inc	hl
	ld	b, (hl)
	inc	hl
	ld	h, (hl)
	ld	l, b
	
	ex	de, hl
	ld	b, (hl)
	ex	de, hl
	
	push	bc
	call	zp.chunk_atend
	pop	bc
	pop	hl
	call	nc, vect_next
	
	pop	af
	out	(map_bankB_port), a
	
	ld	a, b
	
	pop	bc
	or	a
	ret

; brief : write a character (byte) from file
; input : hl -> pointer to FILE object, a -> character
; output : none
; destroys : a, de
vect_fputc:
	call	vect_feof
	jr	nz, vect_fputc.unsafe
	; make room for the byte
	
	; weird huh? that's the price of short-circuiting...
	; this will make the file grow by one byte
	; (todo : make more room to areduce the number of grow
	; in case caller is too stupid to reserve memory himself...)
	ld	de, -1
	call	vect_fgrow
	
vect_fputc.unsafe:
	push	bc
	
	ld	b, a
	in	a, (map_bankB_port)
	push	af
	
	push	hl
	inc	hl
	
	ld	a, (hl)
	inc	hl
	ld	e, (hl)
	inc	(hl)
	inc	hl
	ld	d, (hl)
	jr	nz, $+3
	inc	(hl)
	inc	hl
	ld	c, (hl)
	inc	hl
	
	out	(map_bankB_port), a
	ld	a, b
	ld	(de), a
	
	ld	b, 0
	add	hl, bc
	add	hl, bc
	add	hl, bc
	
	ld	a, (hl)
	inc	hl
	ld	b, (hl)
	inc	hl
	ld	h, (hl)
	ld	l, b
	
	call	zp.chunk_atend
	pop	hl
	call	nc, vect_next
	
	pop	af
	out	(map_bankB_port), a
	
	pop	bc
	ret

; brief : adjust FILE object when moving to next chunk
; input : hl -> pointer to FILE object, c -> current chunk
; output : CF set if last chunk reached
; destroys : a, de
vect_next:
	ld	a, c
	cp	(hl)
	ccf
	ret	c
	
	call	zp.throw
	
	push	hl
	
	push	hl
	inc c
	add	a, 2
	add	a, a
	add	a, c
	offset_hl
	ld	a, (hl)
	inc	hl
	ld	e, (hl)
	inc	hl
	ld	d, (hl)
	pop	hl
	
	inc	hl
	
	ld	(hl), a
	inc	hl
	
	inc	de
	inc	de
	ld	a, (de)
	inc	de
	offset_de
	
	ld	(hl), e
	inc	hl
	ld	(hl), d
	inc	hl
	
	inc	(hl)
	
	pop	hl
	or	a
	ret

vat.test:
	call	load
	ret	c
	call	vect_fsize
	push	hl
	call	zp.malloc
	ld	(vat_loc), hl
	ex	de, hl
	pop	hl
	call	vect_fread
	
	; do something with that VAT
	
	
	; save it back to file...
	ld	bc, 
	push	bc
	call	vect_fresize
	ld	de, 0
	call	vect_fseek
	ld	de, (vat_loc)
	pop	bc
	call	vect_fwrite
	jp	save

load:
	ld	hl, vat_dump
	call	zp.fopen
	ld	(vat_FILE), hl
	ret	nc
	ld	hl, vat_dump
	ld	bc, 
	call	zp.file_create
	jr	nc, load
	ret

save:
	ld	hl, (vat_FILE)
	ld	bc, 
	call	vect_fresize
	
	ld	de, 
	call	vect_fwrite
	jp	zp.fclose

vat_loc:
	.dw 0

vat_FILE:
	.dw	0

vat_dump:
	.db "compat-vat", 0

.end